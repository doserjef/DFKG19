arrange(recording.site, day, time, year) %>%
select(ndsi)
ordered.dat$ndsi <- ndsi.ordered
# AEI
aei.dat <- extractMultipleSounds("../data/AEI.csv", index = 'AEI')
aei.ordered <- aei.dat %>%
arrange(recording.site, day, time, year) %>%
select(AEI)
ordered.dat$aei <- aei.ordered
# Treatment Indicator variable
ordered.dat$trt <- ifelse(ordered.dat$recording.site %in% c("LA09", "LA10", "LA11", "LA12"),
1, 0)
head(ordered.dat)
range(ordered.dat$H)
range(ordered.dat$aei)
range(ordered.dat$ndsi)
range(ordered.dat$aci)
range(log(ordered.dat$aci))
log(0.5)
write.csv(ordered.dat, "../data/orderedIndices.csv")
rm(list = ls())
source("~/Dropbox/libs/soundscape.R")
library(dplyr)
# 08-additionalIndexComputations ------------------------------------------
# multiple_sounds(directory = "../recordings/", resultfile = "../data/aci.csv",
# soundindex ="acoustic_complexity", no_cores = 2)
# Organize Data sets ------------------------------------------------------
# H
full.dat <- extractMultipleSounds("../data/H.csv", index = "H")
# Properly structure data
n <- dim(full.dat)[1]
ordered.dat <- full.dat %>%
arrange(recording.site, day, time, year)
head(ordered.dat, 30)
# ACI
aci.dat <- extractMultipleSounds("../data/aci.csv", index = 'ACI')
aci.ordered <- aci.dat %>%
arrange(recording.site, day, time, year) %>%
select(ACI)
ordered.dat$aci <- aci.ordered
# NDSI
ndsi.dat <- extractMultipleSounds("../data/ndsi.csv", index = 'ndsi')
ndsi.ordered <- ndsi.dat %>%
arrange(recording.site, day, time, year) %>%
select(ndsi)
ordered.dat$ndsi <- ndsi.ordered
# AEI
aei.dat <- extractMultipleSounds("../data/AEI.csv", index = 'AEI')
aei.ordered <- aei.dat %>%
arrange(recording.site, day, time, year) %>%
select(AEI)
ordered.dat$aei <- aei.ordered
# Treatment Indicator variable
ordered.dat$trt <- ifelse(ordered.dat$recording.site %in% c("LA09", "LA10", "LA11", "LA12"),
1, 0)
head(ordered.dat)
?write.csv
write.csv(ordered.dat, "../data/orderedIndices.csv", row.names = FALSE, col.names = TRUE)
test <- read.csv("../data/orderedIndices.csv")
test <- read.csv("../data/orderedIndices.csv", header = TRUE)
str(ordered.dat)
rm(list = ls())
source("~/Dropbox/libs/soundscape.R")
library(dplyr)
# 08-additionalIndexComputations ------------------------------------------
# multiple_sounds(directory = "../recordings/", resultfile = "../data/aci.csv",
# soundindex ="acoustic_complexity", no_cores = 2)
# Organize Data sets ------------------------------------------------------
# H
full.dat <- extractMultipleSounds("../data/H.csv", index = "H")
# Properly structure data
n <- dim(full.dat)[1]
ordered.dat <- full.dat %>%
arrange(recording.site, day, time, year)
head(ordered.dat, 30)
# ACI
aci.dat <- extractMultipleSounds("../data/aci.csv", index = 'ACI')
aci.ordered <- aci.dat %>%
arrange(recording.site, day, time, year) %>%
select(ACI)
ordered.dat$aci <- aci.ordered$ACI
# NDSI
ndsi.dat <- extractMultipleSounds("../data/ndsi.csv", index = 'ndsi')
ndsi.ordered <- ndsi.dat %>%
arrange(recording.site, day, time, year) %>%
select(ndsi)
ordered.dat$ndsi <- ndsi.ordered$ndsi
# AEI
aei.dat <- extractMultipleSounds("../data/AEI.csv", index = 'AEI')
aei.ordered <- aei.dat %>%
arrange(recording.site, day, time, year) %>%
select(AEI)
ordered.dat$aei <- aei.ordered$AEI
# Treatment Indicator variable
ordered.dat$trt <- ifelse(ordered.dat$recording.site %in% c("LA09", "LA10", "LA11", "LA12"),
1, 0)
str(ordered.dat)
write.csv(ordered.dat, "../data/orderedIndices.csv", row.names = FALSE)
rm(list = ls())
library(rgdal)
library(sp)
library(raster)
library(sf)
library(maps)
library(dplyr)
library(ggplot2)
library(grid)
library(gridExtra)
library(ggmap)
library(ggrepel)
# For us map
library(usmap)
# Computation of a graphic for the logging area used in IBAC presentation
# 07-mapOfLoggingArea -----------------------------------------------------
locations <- read.csv("../data/siteLocations.csv")
coordinates(locations) <- ~long + lat
proj4string(locations) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
trt.dat <- readOGR(dsn = "../data/", layer = "Michigan_State_Forest_Treatment_History")
names(trt.dat)
point.trt.info <- over(locations, trt.dat)
str(point.trt.info)
trt.dat.dfg <- trt.dat[trt.dat@data$OBJECTID == point.trt.info$OBJECTID[10], ]
trt.dat.dfg
trt.dat.dfg@data
plot(trt.dat.dfg)
trt.dat.dfg@data
trt.dat.dfg@data
names(trt.dat.dfg@data)
trt.dat.dfg@data$COVERTYPEO
trt.dat.dfg@data
test <- read.csv("../data/full-ndsi-psd-ordered.csv")
head(test)
13 * 5
11556 / 1566
head(test, 40)
head(test, 100)
library(dplyr)
test %>% select(recording.site, year, month, day, time) %>% print(n = 300)
test %>% select(recording.site, year, month, day, time)
tail(test)
new.test <- read.csv("../data/orderedMultivariateData.csvr")
new.test <- read.csv("../data/orderedMultivariateData.csv")
head(new.test)
new.test <- read.csv("../data/orderedIndices.csv")
head(new.test)
rm(list = ls())
library(rgdal)
library(sp)
library(raster)
library(sf)
library(maps)
library(dplyr)
library(ggplot2)
library(grid)
library(gridExtra)
library(ggmap)
library(ggrepel)
# For us map
library(usmap)
# Computation of a graphic for the logging area used in IBAC presentation
# 07-mapOfLoggingArea -----------------------------------------------------
locations <- read.csv("../data/siteLocations.csv")
coordinates(locations) <- ~long + lat
proj4string(locations) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
trt.dat <- readOGR(dsn = "../data/", layer = "Michigan_State_Forest_Treatment_History")
point.trt.info <- over(locations, trt.dat)
trt.dat.dfg <- trt.dat[trt.dat@data$OBJECTID == point.trt.info$OBJECTID[10], ]
plot(trt.dat.dfg)
points(locations)
trt.dat.dfg
str(trt.dat)
unique(trt.dat@data$DATE_TREAT)
trt.dat.dfg
trt.dat.dfg@data
view(trt.dat.dfg@data)
View(trt.dat.dfg@data)
# 09-forestLoggingCriteria ------------------------------------------------
rm(list = ls())
library(rgdal)
library(sp)
library(raster)
library(sf)
library(maps)
library(dplyr)
library(ggplot2)
library(grid)
library(gridExtra)
library(ggmap)
library(ggrepel)
# For us map
library(usmap)
locations <- read.csv("../data/siteLocations.csv")
coordinates(locations) <- ~long + lat
proj4string(locations) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
# 09-forestLoggingCriteria ------------------------------------------------
rm(list = ls())
library(rgdal)
library(sp)
library(raster)
library(sf)
library(maps)
library(dplyr)
library(ggplot2)
library(grid)
library(gridExtra)
library(ggmap)
library(ggrepel)
# For us map
library(usmap)
locations <- read.csv("../data/siteLocations.csv")
coordinates(locations) <- ~long + lat
proj4string(locations) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
trt.dat <- readOGR(dsn = "../data/miForestData/", layer = "Michigan_State_Forest_Treatments")
point.trt.info <- over(locations, trt.dat)
point.trt.info$OBJECTID[1]
point.trt.info$OBJECTID[10]
trt.dat.dfg <- trt.dat[trt.dat@data$OBJECTID == point.trt.info$OBJECTID[10], ]
head(pont.trt.info)
head(point.trt.info$FC_Key)
unique(point.trt.info$FC_Key)
point.trt.info[point.trt.info$FC_Key == 54175, ]
rm(list = ls())
library(rgdal)
library(sp)
library(raster)
library(sf)
library(maps)
library(dplyr)
library(ggplot2)
library(grid)
library(gridExtra)
library(ggmap)
library(ggrepel)
# For us map
library(usmap)
# Computation of a graphic for the logging area used in IBAC presentation
# 07-mapOfLoggingArea -----------------------------------------------------
locations <- read.csv("../data/siteLocations.csv")
coordinates(locations) <- ~long + lat
proj4string(locations) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
trt.dat <- readOGR(dsn = "../data/", layer = "Michigan_State_Forest_Treatment_History")
point.trt.info <- over(locations, trt.dat)
trt.dat.dfg <- trt.dat[trt.dat@data$OBJECTID == point.trt.info$OBJECTID[10], ]
point.trt.info
rm(list = ls())
library(rgdal)
library(sp)
library(raster)
library(sf)
library(maps)
library(dplyr)
library(ggplot2)
library(grid)
library(gridExtra)
library(ggmap)
library(ggrepel)
# For us map
library(usmap)
# Computation of a graphic for the logging area used in IBAC presentation
# 07-mapOfLoggingArea -----------------------------------------------------
locations <- read.csv("../data/siteLocations.csv")
coordinates(locations) <- ~long + lat
proj4string(locations) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
trt.dat <- readOGR(dsn = "../data/", layer = "Michigan_State_Forest_Treatment_History")
rm(list = ls())
library(rgdal)
library(sp)
library(raster)
library(sf)
library(maps)
library(dplyr)
library(ggplot2)
library(grid)
library(gridExtra)
library(ggmap)
library(ggrepel)
# For us map
library(usmap)
# Computation of a graphic for the logging area used in IBAC presentation
# 07-mapOfLoggingArea -----------------------------------------------------
locations <- read.csv("../data/siteLocations.csv")
coordinates(locations) <- ~long + lat
proj4string(locations) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
trt.dat <- readOGR(dsn = "../data/", layer = "Michigan_State_Forest_Treatment_History")
point.trt.info <- over(locations, trt.dat)
trt.dat.dfg <- trt.dat[trt.dat@data$OBJECTID == point.trt.info$OBJECTID[10], ]
plot(trt.dat.dfg)
points(locations)
register_google(key = "AIzaSyBPAwSY5x8vQqlnG-QwiCAWQW12U3CTLZY")
michgmap.small <- get_map(location = c(-84.293, 45.537), zoom = 14, maptype = 'roadmap')
basemap <- ggmap(michgmap.small)
gg.locations <- data.frame(locations)
gg.locations <- gg.locations[, c("site", "lat", "long")]
gg.locations$type <- c(rep("Control", 9), rep("Treatment", 4))
gg.trt.dat.dfg <- fortify(trt.dat.dfg)
# TODO: add the recording location names using the ggrepel package. Can check out
# the FOR875 code and see whats up there.
main <- basemap +
xlab("Longitude") +
ylab("Latitude") +
geom_polygon(data = gg.trt.dat.dfg, aes(x = long, y = lat, color = 'black'),
show.legend = TRUE, fill = 'black', alpha = 0.4) +
geom_point(data = gg.locations, aes(x = long, y = lat), size = 3,
col = 'lightsteelblue') +
labs(color='') +
theme(text = element_text(size = 18)) +
scale_color_manual(labels = 'Shelterwood Logging Area', values = 'cornsilk') +
geom_label_repel(data = gg.locations, aes(x = long, y = lat, label = site), box.padding = unit(.6, "lines"),
label.padding = unit(.15, "lines"),
segment.color = "red", segment.size = 1)
# # Get map of Michigan
mi.dat <- map_data("state") %>% filter(region == "michigan", subregion == "south")
mi.map <- ggplot(data = mi.dat) +
geom_polygon(aes(x = long, y = lat, group = group), fill = "lightblue", color = "black") +
coord_quickmap()
study.bbox <- attr(michgmap.small, "bb")
michigan <- mi.map +
geom_rect(data = study.bbox, aes(xmin = ll.lon, xmax = ur.lon,
ymin = ll.lat, ymax = ur.lat), col = "black",
size = 2) +
scale_x_continuous(breaks = NULL) +
scale_y_continuous(breaks = NULL) +
theme(text = element_text(size = 18)) +
xlab("") +
ylab("") +
theme_classic() +
theme(panel.border = element_rect(color = "black", fill = NA, size = 1),
legend.position = "none")
statepop$myvar <- ifelse(statepop$abbr == "MI", 1, 0)
us.map <- plot_usmap(data = statepop, values = "myvar", color = "black",
exclude = c("Alaska", "Hawaii")) +
scale_fill_continuous(low = "white", high = "lightblue") +
theme(panel.border = element_rect(color = "black", fill = NA, size = 1),
legend.position = "none")
grid.newpage()
v1 <- viewport(width = 0.9, height = 0.9, x = 0.45, y = 0.5)
v2 <- viewport(width = 0.4, height = 0.4, x = 0.81, y = 0.78)
v3 <- viewport(width = 0.3, height = 0.3, x = 0.82, y = 0.3)
print(main, vp = v1)
print(michigan, vp = v2)
print(us.map, vp = v3)
png("../figures/studyArea.png", width = 900, height = 600)
grid.newpage()
v1 <- viewport(width = 0.9, height = 0.9, x = 0.45, y = 0.5)
v2 <- viewport(width = 0.4, height = 0.4, x = 0.81, y = 0.78)
v3 <- viewport(width = 0.3, height = 0.3, x = 0.82, y = 0.3)
print(main, vp = v1)
print(michigan, vp = v2)
print(us.map, vp = v3)
dev.off()
rm(list = ls())
library(dplyr)
# 09-forestLoggingCriteria.R ----------------------------------------------
dat <- read.table("../data/plotLoggingData.txt", skip = 2)
names(dat) <- c('stand', 'plot', 'spp', 'totalTrees', 'totalLogged',
'totalLogs', 'totalSticks')
# 30 = white pine
# 31 = red pine
# 80 = mixed aspen
# 99 = mixed hardwood
# 08 = red oak
# 32 = jack pine
# 05 = basswood
dat %>%
group_by(spp) %>%
summarize(total = sum(totalTrees),
logged = sum(totalLogged),
prop.logged = logged / total)
# This is the volume in coords per acre for the entire plot.
vol.coords.acre <- (sum(dat$totalTrees) + sum(dat$totalSticks)) / 2
dat
out <- dat %>%
group_by(plot) %>%
summarize(sumTrees = sum(totalTrees))
out
unique(dat$plot)
length(unique(dat$plot))
out <- dat %>%
group_by(plot) %>%
summarize(sumTrees = sum(totalTrees) * 10)
out
max(out$sumTrees)
range(out$sumTrees)
mean(out$sumTrees)
# Clear working directory
rm(list =ls())
library(tuneR)
library(dplyr)
library(seewave)
library(soundecology)
# Contains a couple functions for manipulating output from soundecology functions
source("../../libs/soundscape.R")
# This file computes the NDSI and the PSD for all recordings in a directory.
# To compute other acoustic indices, change the soundindex argument
# in the multiple_sounds function
# Compute NDSI for all recordings ------------------------------------------
# multiple_sounds(directory = "../../soundsForJeff/ALL LA SITES-YEARS-0530-0700/",
#                 resultfile = "../data/ndsi.csv",
#                 soundindex ="ndsi", no_cores = 4)
# Extract all necessary data  ---------------------------------------------
full.dat <- extractMultipleSounds("../data/ndsi.csv")
str(full.dat)
full.dat <- extractMultipleSounds("../data/ndsi.csv")
str(full.dat)
n <- dim(full.dat)[1]
n
# Read in the psd file after initial computation
psd.dat <- read.table("../data/psd-raw")
str(full.dat)
str(psd.dat)
# Create a treatment indicator variable that takes value 1 for treatment sites and
# 0 for control sites.
psd.ordered.dat$trt <- ifelse(psd.ordered.dat$recording.site %in%
c("LA09", "LA10", "LA11", "LA12"), 1, 0)
# Read in the psd file after initial computation
psd.dat <- read.table("../data/psd-raw")
# Combine psd and NDSI data
psd.dat <- cbind(psd.dat, full.dat)
# Arrange data by individual soundscape (i.e., by recordings site, day, time, year)
psd.ordered.dat <- psd.dat %>%
arrange(recording.site, day, time, year)
# Create a treatment indicator variable that takes value 1 for treatment sites and
# 0 for control sites.
psd.ordered.dat$trt <- ifelse(psd.ordered.dat$recording.site %in%
c("LA09", "LA10", "LA11", "LA12"), 1, 0)
psd.table <- psd.ordered.dat[, 1:10]
str(psd.table)
str(psd.ordered.dat)
# Read in psd/ndsi data and combine with the rain data
dat <- read.csv("../data/full-ndsi-psd-ordered.csv")
str(dat)
# Read in rain data that was manually determined from the recordings
rain <- read.csv("../data/geophony.csv", stringsAsFactors = FALSE)
# Add information to the rain data frame from the recording name
rain$siteInfo <- sub('.*/', '', rain$X)
rain$year <- as.numeric(substr(rain$siteInfo, 5, 8))
rain$day <- as.numeric(substr(rain$siteInfo, 11, 12))
rain$time <- as.numeric(substr(rain$siteInfo, 14, 19))
rain$X <- NULL
rain$X.1 <- NULL
rain$siteInfo <- NULL
# Join the acoustic index data with the rain data
dat <- left_join(dat, rain, by = c("year", "day", "time"))
n <- nrow(dat)
# Each unique site/day/time combination is an individual
# Create individual identity (i.e., assign each individual soundscape a number)
n.ind.counter <- 1
dat$ind = 1
for (i in 2:n) {
if (sum(dat[i, c("month", "day", "time", "recording.site")] ==
dat[i - 1, c("month", "day", "time", "recording.site")]) == 4) {
dat$ind[i] = dat$ind[i-1]
} else {
dat$ind[i] = dat$ind[i-1] + 1
}
}
# Number of recording years after the treatment
post.trt.years <- 5
X <- matrix(0, nrow = n, ncol = 3 + post.trt.years * 2)
?gather
library(tidyr)
?gather
rm(list = ls())
library(dplyr)
library(tidyr)
# This document creates the design matrix for the multivariate portion of the analysis.
# Here the multivariate design matrix is created for analyzing ten PSD values.
# Author: Jeffrey W. Doser
# 04-psdIntYearDesginMatrix.r ---------------------------------------------
# Read in psd data and rain data, join together
dat <- read.csv("../data/full-ndsi-psd-ordered.csv")
rain <- read.csv("../data/geophony.csv", stringsAsFactors = FALSE)
rain$siteInfo <- sub('.*/', '', rain$X)
rain$year <- as.numeric(substr(rain$siteInfo, 5, 8))
rain$day <- as.numeric(substr(rain$siteInfo, 11, 12))
rain$time <- as.numeric(substr(rain$siteInfo, 14, 19))
rain$X <- NULL
rain$X.1 <- NULL
rain$siteInfo <- NULL
dat <- left_join(dat, rain, by = c("year", "day", "time"))
# Convert data into long format
long.dat <- gather(dat, key = "PSD", value = "value", V1:V10)
# Order data by each "individual" recording site/day/time combo
ordered.long.dat <- long.dat %>%
arrange(recording.site, day, time, year)
ordered.long.dat$X <- NULL
n <- nrow(ordered.long.dat)
# Create indicator variable for each "individual"
ordered.long.dat$ind = 1
for (i in 2:n) {
if (sum(ordered.long.dat[i, c("month", "day", "time", "recording.site")] ==
ordered.long.dat[i - 1, c("month", "day", "time", "recording.site")]) == 4) {
ordered.long.dat$ind[i] = ordered.long.dat$ind[i-1]
} else {
ordered.long.dat$ind[i] = ordered.long.dat$ind[i-1] + 1
}
}
dat <- read.table("../data/plotLoggingData.txt", skip = 2)
names(dat) <- c('stand', 'plot', 'spp', 'totalTrees', 'totalLogged',
'totalLogs', 'totalSticks')
# 30 = white pine
# 31 = red pine
# 80 = mixed aspen
# 99 = mixed hardwood
# 08 = red oak
# 32 = jack pine
# 05 = basswood
out <- dat %>%
group_by(plot) %>%
summarize(sumTrees = sum(totalTrees) * 10)
out
sum(out)
