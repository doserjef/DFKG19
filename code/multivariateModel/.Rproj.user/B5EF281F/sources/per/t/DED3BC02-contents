rm(list = ls())
# Multivariate normal random number generator -----------------------------

rmvn <- function(n, mu=0, V = matrix(1)){
  p <- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D <- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

# Logit data transformation
logit <- function(theta, a, b) {
  log((theta-a)/(b-theta))
}

# Inverse logit transformation
logit.inv <- function(z, a, b) {
  b-(b-a)/(1+exp(z))
}


# Simulate Data -----------------------------------------------------------

set.seed(1)
n.sites <- 13
n.dc <- 4
n.days <- 30
n.years <- 5
n.psd <- 10
n <- n.sites * n.dc * n.days * n.years * n.psd
n.ind <- n.days * n.dc * n.sites * n.psd
n.ind.one <- n.days * n.dc * n.sites

n.alpha <- ((n.years - 1) * 2 + 2) * n.psd
# Fixed effect coefficients
alpha <- rnorm(n.alpha, 0, 2)
# Process variance
sigma.sq <- 2
# Random effect covariance matrix
lambda <- matrix(0, nrow = n.psd, ncol = n.psd)
diag(lambda) <- 1.5
# Individual random effects
n.beta <- 1
beta.mu <- rep(0, 10)
beta.mat <- rmvn(n.ind.one, beta.mu, lambda)
beta <- c(beta.mat)
# beta.1 <- rnorm(n.ind, 0, sd = sqrt(tau.1))
# beta <- cbind(beta.0, beta.1)

n.trt <- 4
n.ctrl <- n.sites - n.trt


# Construct design matrix -------------------------------------------------

# Create treatment groups
trt.ind <- rep(0, n)
trt.ind[1:(6000*n.trt)] <- 1
year <- rep(rep(c(2013, 2014, 2015, 2016, 2017), each = n.psd), length.out = n)
psd.ind <- rep(1:n.psd, length.out = n)
X <- matrix(0, ncol = ((n.years - 1) * 2 + 2) * n.psd, nrow = n)
num <- ncol(X) / n.psd
for (i in 1:n.psd) {
  # Respective intercept for each 
  X[, (i-1)*num + 1] <- ifelse(psd.ind == i, 1, 0)
  X[, (i-1)*num + 2] <- ifelse(psd.ind == i & trt.ind == 1, 1, 0)
  X[, (i-1)*num + 3] <- ifelse(psd.ind == i & year == 2014, 1, 0)
  X[, (i-1)*num + 4] <- ifelse(psd.ind == i & year == 2015, 1, 0)
  X[, (i-1)*num + 5] <- ifelse(psd.ind == i & year == 2016, 1, 0)
  X[, (i-1)*num + 6] <- ifelse(psd.ind == i & year == 2017, 1, 0)
  X[, (i-1)*num + 7] <- ifelse(psd.ind == i & year == 2014 & trt.ind == 1, 1, 0)
  X[, (i-1)*num + 8] <- ifelse(psd.ind == i & year == 2015 & trt.ind == 1, 1, 0)
  X[, (i-1)*num + 9] <- ifelse(psd.ind == i & year == 2016 & trt.ind == 1, 1, 0)
  X[, (i-1)*num + 10] <- ifelse(psd.ind == i & year == 2017 & trt.ind == 1, 1, 0)
}

# Indicator for individual
ind <- rep(1:n.ind.one, each = n.years * n.psd)

# Construct likelihood
V <- diag(sigma.sq, n.years*n.psd)
y <- rep(0, n)
for (i in 1:n.ind.one) {
  x.i <- X[ind == i, ]
  # W.i <- W[ind == i, ]
  # v <- x.i %*% alpha + rep(1, n.years)*beta.0[i] + w.i * beta.1[i]
  v <- x.i %*% alpha + beta[((i-1)*n.psd + 1):(((i-1)*n.psd) + n.psd)]
  y[((i-1)*n.years*n.psd + 1):(((i-1)*n.years*n.psd)+n.years*n.psd)] <- rmvn(n = 1, mu = v, V = V)
}

write.table(X, "sim-X", col.names = FALSE, row.names = FALSE, sep = "\t")
write.table(y, "sim-y", col.names = FALSE, row.names = FALSE, sep = "\t")
write.table(beta, "sim-beta", col.names = FALSE, row.names = FALSE, sep = "\t")
write.table(alpha, "sim-alpha", col.names = FALSE, row.names = FALSE, sep = "\t")

