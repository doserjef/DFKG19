theme(axis.text=element_text(size=14),
axis.title=element_text(size=18),
plot.margin = margin(t = 16, r = 16, b = 0, l = 5, unit = "pt"))
dev.off()
# ndsi <- as.matrix(read.table("../../data/ndsi"))[, 1]
ndsi <- as.matrix(read.csv("../../data/orderedIndices.csv")$ndsi)
y <- as.matrix(logit(ndsi, a = -1, b = 1))
X <- as.matrix(read.table("../../data/X-year"))
dim(X)
# Subroutines -----------------------------------------------------------
# Multivariate normal random number generator
rmvn <- function(n, mu=0, V = matrix(1)){
p <- length(mu)
if(any(is.na(match(dim(V),p))))
stop("Dimension problem!")
D <- chol(V)
t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}
# Inverse Gamma random number generator
rigamma <- function(n, a, b){
1/rgamma(n = n, shape = a, rate = b)
}
# Logit transformation
logit <- function(theta, a, b) {
log((theta-a)/(b-theta))
}
# Inverse logit transformation
logit.inv <- function(z, a, b) {
b-(b-a)/(1+exp(z))
}
library(coda)
y <- as.matrix(logit(ndsi, a = -1, b = 1))
dim(y)
rm(list = ls())
library(coda)
source("singleIndexModel.R")
rm(list = ls())
library(coda)
source("singleIndexModel.R")
# Main Program ------------------------------------------------------------
out <- univar.sound.model(n.iter = 500,
n.sites = 13,
data = read.csv("../../data/orderedIndices.csv")$ndsi,
ind = read.table("../../data/ind")[, 1],
X = as.matrix(read.table("../../data/X-year")),
alpha.start = 0,
beta.start = 0,
sigma.sq.start = 1,
tau.sq.start = 1)
alpha.samples <- out$alpha.samples
sigma.sq.samples <- out$sigma.sq.samples
tau.sq.samples <- out$tau.sq.samples
post.dens.samples <- out$post.dens.samples
post.log.dens.samples <- out$post.log.dens.samples
# Compute WAIC
ppd <- sum(log(apply(post.dens.samples, 1, sum) / n.samples))
p.d <- sum(apply(post.log.dens.samples, 1, var))
waic <- -2 * ppd + 2 * p.d
n.iter <- 500
# Compute WAIC
ppd <- sum(log(apply(post.dens.samples, 1, sum) / n.iter))
p.d <- sum(apply(post.log.dens.samples, 1, var))
waic <- -2 * ppd + 2 * p.d
waic
theta <- cbind(t(alpha.samples), tau.sq.samples, sigma.sq.samples)
colnames(theta) <- c(paste0("alpha.", 0:(n.alpha-1)), "tau.sq.", "sigma.sq")
dim(alpha.samples)
n.alpha <- ncol(alpha.samples)
colnames(theta) <- c(paste0("alpha.", 0:(n.alpha-1)), "tau.sq.", "sigma.sq")
n.alpha
n.alpha <- nrow(alpha.samples)
colnames(theta) <- c(paste0("alpha.", 0:(n.alpha-1)), "tau.sq.", "sigma.sq")
n.iter <- 500
theta.1 <- t(matrix(scan("theta-samples-1"), ncol = n.iter, byrow = F))
theta.2 <- t(matrix(scan("theta-samples-2"), ncol = n.iter, byrow =F))
theta.3 <- t(matrix(scan("theta-samples-3"), ncol = n.iter, byrow = F))
burn.in <- floor(0.1 * n.iter)
sub <- (burn.in+1):n.iter
# overlaps with zero, suggests there are no differences in b/w control and treatment.
ctrl.alpha.post <- as.data.frame(m.quants.1[3:7, ])
row.names(ctrl.alpha.post) <- c("ctrl2014", "ctrl2015", "ctrl2016", "ctrl2017", "ctrl2018")
rm(list = ls())
library(coda)
library(ggplot2)
library(tidyr)
library(dplyr)
# Posterior summary information from the single index model output.
# Author: Jeffrey W. Doser
# summary.R ---------------------------------------------------------------
n.iter <- 500
theta.1 <- t(matrix(scan("theta-samples-1"), ncol = n.iter, byrow = F))
n.alpha <- 13
# n.alpha <- 12
# n.alpha <- 11
colnames(theta.1) <- c(paste0("alpha.", 0:(n.alpha-1)), "tau.sq.", "sigma.sq")
burn.in <- floor(0.1 * n.iter)
sub <- (burn.in+1):n.iter
m.quants.1 <- summary(window(mcmc(theta.1), start = burn.in))$quantiles
# overlaps with zero, suggests there are no differences in b/w control and treatment.
ctrl.alpha.post <- as.data.frame(m.quants.1[3:7, ])
row.names(ctrl.alpha.post) <- c("ctrl2014", "ctrl2015", "ctrl2016", "ctrl2017", "ctrl2018")
years <- c(2014:2018)
ctrl.alpha.post$years <- years
trt.alpha.post <- as.data.frame(m.quants.1[8:12, ])
row.names(trt.alpha.post) <- c("trt2014", "trt2015", "trt2016", "trt2017", "trt2018")
trt.alpha.post$years <- years
m.quants.1
plot(years, trt.alpha.post[, 3], axes = FALSE, cex = 1.25, pch = 19, cex.lab = 1.5, cex.axis = 1.5,
xlab = "Year", ylab = 'Year Effects',
ylim = c(min(trt.alpha.post[, 1]), max(trt.alpha.post[, 5])), xpd = TRUE
)
abline(h = 0, lty = 2)
segments(years, trt.alpha.post[, 1], years, trt.alpha.post[, 5], col = 'grey', lwd = 1.5)
axis(1, cex.axis = 1.25)
axis(2, at = seq(-2, .5, by = 0.5), labels = seq(-2, .5, by = 0.5), las = 1, xpd = TRUE,
cex.axis = 1.25)
dev.off()
single.plot.dat <- data.frame(year = trt.alpha.post$years,
low = trt.alpha.post[, 1],
med = trt.alpha.post[, 3],
high = trt.alpha.post$`97.5%`,
index = 'NDSI')
theme_set(theme_bw(base_size = 18))
ggplot(data = single.plot.dat, aes(x = year)) +
geom_point(aes(y = med), size = 2.5) +
geom_segment(aes(x = year, y = low, xend = year, yend = high),
color = 'red', size = 0.9) +
facet_wrap(index ~ ., scales = "free_y") +
geom_hline(yintercept = 0, linetype = 'dashed', col = 'black') +
labs(x = 'Year', y = 'Year Effect') +
theme(axis.text=element_text(size=14),
axis.title=element_text(size=18),
plot.margin = margin(t = 16, r = 16, b = 0, l = 5, unit = "pt"))
vals.post.burn <- window(mcmc(theta.1), start = burn.in)
dat <- as.data.frame(vals.post.burn)
dat.long <- gather(dat, key = 'Variable', value = 'val')
dat.long.sub <- dat.long %>%
filter(Variable %in% c("alpha.1", "alpha.7", "alpha.8", "alpha.9", "alpha.10",
"alpha.11", "alpha.12", "sigma.sq", "tau.sq."))
dat.long.sub$Variable <- factor(dat.long.sub$Variable,
levels = c('alpha.1', 'alpha.7', 'alpha.8',
'alpha.9', 'alpha.10', 'alpha.11',
'alpha.12', 'sigma.sq', 'tau.sq.'))
vals.post.burn <- window(mcmc(theta.1), start = burn.in)
dat <- as.data.frame(vals.post.burn)
dat.long <- gather(dat, key = 'Variable', value = 'val')
dat.long.sub <- dat.long %>%
filter(Variable %in% c("alpha.1", "alpha.7", "alpha.8", "alpha.9", "alpha.10",
"alpha.11", "alpha.12", "sigma.sq", "tau.sq."))
dat.long.sub$Variable <- factor(dat.long.sub$Variable,
levels = c('alpha.1', 'alpha.7', 'alpha.8',
'alpha.9', 'alpha.10', 'alpha.11',
'alpha.12', 'sigma.sq', 'tau.sq.'))
plot_names <- c(
`alpha.1` = 'scriptstyle(bgroup("", a, ")"))~alpha[2]',
`alpha.7` = 'scriptstyle(bgroup("", b, ")"))~alpha[8]',
`alpha.8` = 'scriptstyle(bgroup("", c, ")"))~alpha[9]',
`alpha.9` = 'scriptstyle(bgroup("", d, ")"))~alpha[10]',
`alpha.10` = 'scriptstyle(bgroup("", e, ")"))~alpha[11]',
`alpha.11` = 'scriptstyle(bgroup("", f, ")"))~alpha[12]',
`alpha.12` = 'scriptstyle(bgroup("", g, ")"))~alpha[13]',
`sigma.sq` = 'scriptstyle(bgroup("", h, ")"))~sigma^2',
`tau.sq.` = 'scriptstyle(bgroup("", i, ")"))~tau^2'
)
theme_set(theme_bw(base_size = 18))
ggplot(data = dat.long.sub, aes(x = val, fill = 'black')) +
geom_density(alpha = 0.5) +
geom_vline(xintercept = 0, linetype = 'dashed', col = 'black') +
guides(fill = FALSE) +
facet_wrap(Variable ~ ., scales = "free_y", labeller = as_labeller(plot_names, label_parsed)) +
labs(x = 'Parameter Value', y = 'Density') +
theme(axis.text=element_text(size=14),
axis.title=element_text(size=18),
plot.margin = margin(t = 16, r = 16, b = 0, l = 5, unit = "pt"))
rm(list = ls())
library(coda)
library(ggplot2)
library(tidyr)
library(dplyr)
n.iter <- 500
theta.full <- t(matrix(scan("theta-samples-1"), ncol = n.iter, byrow = F))
n.alpha <- 13
colnames(theta.full) <- c(paste0("alpha.", 0:(n.alpha - 1)), "tau.sq.", "sigma.sq")
theta.no.diffs <- t(matrix(scan("theta-no-diffs-samples"), ncol = n.iter, byrow = F))
colnames(theta.no.diffs) <- colnames(theta.full)[-2]
theta.no.rain <- t(matrix(scan("theta-no-rain-samples"), ncol = n.iter, byrow = F))
colnames(theta.no.rain) <- colnames(theta.full)[-13]
theta.no.re <- t(matrix(scan("no-beta-theta-samples"), ncol = n.iter, byrow = F))
colnames(theta.no.re) <- colnames(theta.full)[-14]
theta.no.all <- t(matrix(scan("no-beta-diff-rain-theta-samples"), ncol = n.iter,
byrow = F))
colnames(theta.no.all) <- colnames(theta.full)[-c(2, 13, 14)]
burn.in <- floor(0.1 * n.iter)
sub <- (burn.in+1):n.iter
quants.full <- summary(window(mcmc(theta.full), start = burn.in))$quantiles
quants.no.diffs <- summary(window(mcmc(theta.no.diffs), start = burn.in))$quantiles
quants.no.rain <- summary(window(mcmc(theta.no.rain), start = burn.in))$quantiles
quants.no.re <- summary(window(mcmc(theta.no.re), start = burn.in))$quantiles
quants.no.all <- summary(window(mcmc(theta.no.all), start = burn.in))$quantiles
all.quants <- rbind(quants.full, quants.no.diffs, quants.no.rain,
quants.no.re, quants.no.all)
vals <- row.names(all.quants)
all.quants <- as.data.frame(all.quants, row.names = FALSE)
all.quants$vals <- vals
years <- c(2014:2018)
trt.alpha.post <- all.quants %>%
filter(vals %in% c('alpha.7', 'alpha.8', 'alpha.9', 'alpha.10', 'alpha.11'))
# trt.alpha.post$model <- rep(c('Full', paste('No ', expression(alpha[2]), sep = ''),
#                               paste('No ', expression(alpha[13]), sep = ''),
#                               paste('No ', expression(tau^2), sep = ''),
#                               paste('No ', expression(alpha[2]), ', ',
#                                     expression(alpha[13]), ', ',
#                                     expression(tau^2), sep = '')),
#                             each = length(years))
trt.alpha.post$model <- factor(rep(c('Full', 'No Inherent Differences', 'No Rain Effect',
'No Random Effects', 'Basic'),
each = length(years)))
trt.alpha.post$model <- factor(rep(1:5, each = length(years)), levels = c(1, 2, 3, 4, 5),
labels = c('Full', 'No Inherent Differences',
'No Rain Effect', 'No Random Effects', 'Basic'))
trt.alpha.post$years <- rep(years, 5)
trt.alpha.post$years[1:5] <- trt.alpha.post$years[1:5] - .2
trt.alpha.post$years[6:10] <- trt.alpha.post$years[6:10] - .1
trt.alpha.post$years[11:15] <- trt.alpha.post$years[11:15]
trt.alpha.post$years[16:20] <- trt.alpha.post$years[16:20] + .1
trt.alpha.post$years[21:25] <- trt.alpha.post$years[21:25] + .2
single.plot.dat <- data.frame(year = trt.alpha.post$years,
low = trt.alpha.post[, 1],
med = trt.alpha.post[, 3],
high = trt.alpha.post$`97.5%`,
vals = trt.alpha.post$vals,
model = trt.alpha.post$model,
index = 'NDSI')
theme_set(theme_bw(base_size = 18))
ggplot(data = single.plot.dat, aes(x = year, col = model, shape = model)) +
geom_point(aes(y = med), size = 2.5) +
geom_segment(aes(x = year, y = low, xend = year, yend = high), size = 0.9) +
facet_wrap(index ~ ., scales = "free_y") +
geom_hline(yintercept = 0, linetype = 'dashed', col = 'black') +
labs(x = 'Year', y = 'Year Effect', col = 'Model', shape = 'Model') +
theme(axis.text=element_text(size=14),
axis.title=element_text(size=18),
plot.margin = margin(t = 16, r = 16, b = 0, l = 5, unit = "pt"))
rm(list = ls())
source("sim.R")
dat <- sim.univariate.data()
str(dat)
source("singleIndexModel.R")
rm(list = ls())
source("sim.R")
source("singleIndexModel.R")
library(coda)
dat <- sim.univariate.data()
dat <- sim.univariate.data()
out <- univar.sound.model(n.iter = 500, n.sites = dat$n.sites, data = dat$y,
ind = dat$ind, X = dat$X, alpha.start = 0,
beta.start = 0, sigma.sq.start = 1,
tau.sq.start = 1)
warnings()
alpha.samples <- out$alpha.samples
tau.sq.samples <- out$tau.sq.samples
sigma.sq.samples <- out$sigma.sq.samples
beta.samples <- out$beta.samples
n.iter <- out$n.iter
plot(mcmc(t(alpha.samples)),density = FALSE)
str(alpha.samples)
dat$X
str(dat$y)
range(dat$y)
dat$n.sites
dat$ind
n.iter = 500
n.sites = dat$n.sites
data = dat$y
ind = dat$ind
X = dat$X
alpha.start = 0
beta.start = 0
sigma.sq.start = 1
tau.sq.start = 1
# Subroutines -----------------------------------------------------------
# Multivariate normal random number generator
rmvn <- function(n, mu=0, V = matrix(1)){
p <- length(mu)
if(any(is.na(match(dim(V),p))))
stop("Dimension problem!")
D <- chol(V)
t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}
# Inverse Gamma random number generator
rigamma <- function(n, a, b){
1/rgamma(n = n, shape = a, rate = b)
}
# Logit transformation
logit <- function(theta, a, b) {
log((theta-a)/(b-theta))
}
# Inverse logit transformation
logit.inv <- function(z, a, b) {
b-(b-a)/(1+exp(z))
}
min(data)
?switch
rm(list = ls())
source("sim.R")
source("singleIndexModel.R")
library(coda)
# Main program for testing the univariate model with simulated data
# Author: Jeffrey W. Doser
# sim-main.R --------------------------------------------------------------
# Simulate data
dat <- sim.univariate.data()
# Run the model
out <- univar.sound.model(n.iter = 500, n.sites = dat$n.sites, data = dat$y,
ind = dat$ind, X = dat$X, alpha.start = 0,
beta.start = 0, sigma.sq.start = 1,
tau.sq.start = 1)
alpha.samples <- out$alpha.samples
tau.sq.samples <- out$tau.sq.samples
sigma.sq.samples <- out$sigma.sq.samples
beta.samples <- out$beta.samples
n.iter <- out$n.iter
warnings()
alpha.samples <- out$alpha.samples
str(alpha.samples)
range(dat$y)
range(dat$X)
rm(list = ls())
source("sim.R")
source("singleIndexModel.R")
library(coda)
# Simulate data
dat <- sim.univariate.data()
n.iter = 500
n.sites = dat$n.sites
data = dat$y
ind = dat$ind
X = dat$X
alpha.start = 0
beta.start = 0
sigma.sq.start = 1
tau.sq.start = 1
require(coda)
# Subroutines -----------------------------------------------------------
# Multivariate normal random number generator
rmvn <- function(n, mu=0, V = matrix(1)){
p <- length(mu)
if(any(is.na(match(dim(V),p))))
stop("Dimension problem!")
D <- chol(V)
t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}
# Inverse Gamma random number generator
rigamma <- function(n, a, b){
1/rgamma(n = n, shape = a, rate = b)
}
# Logit transformation
logit <- function(theta, a, b) {
log((theta-a)/(b-theta))
}
# Inverse logit transformation
logit.inv <- function(z, a, b) {
b-(b-a)/(1+exp(z))
}
index = 'sim'
# Subroutines -----------------------------------------------------------
# Multivariate normal random number generator
rmvn <- function(n, mu=0, V = matrix(1)){
p <- length(mu)
if(any(is.na(match(dim(V),p))))
stop("Dimension problem!")
D <- chol(V)
t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}
# Inverse Gamma random number generator
rigamma <- function(n, a, b){
1/rgamma(n = n, shape = a, rate = b)
}
# Logit transformation
logit <- function(theta, a, b) {
log((theta-a)/(b-theta))
}
# Inverse logit transformation
logit.inv <- function(z, a, b) {
b-(b-a)/(1+exp(z))
}
# Will need to change accordingly when using different acoustic indices.
y <- switch(index,
'ndsi' = as.matrix(logit(data, a = -1, b = 1)),
'H' = as.matrix(logit(data, a = 0, b = 1)),
'AEI' = as.matrix(logit(data, a = 0, b = 1)),
'ACI' = as.matrix(log(data)),
'sim' = as.matrix(data)
)
range(y)
n.ind <- length(unique(ind))
n <- nrow(X)
W <- as.matrix(rep(1, n))
n.alpha <- dim(X)[2]
n.beta <- dim(W)[2]
s <- rep(0, n.ind)
for (i in 1:n.ind) {
curr <- sum(ind == i)
s[i] <- curr
}
# Normal non-informative prior on regression coefficients
alpha.mu <- rep(0, n.alpha)
alpha.var <- rep(10000, n.alpha)
# Normal prior on random individual effects
beta.mu <- matrix(0, nrow = n.ind, ncol = n.beta)
# Inverse gamma prior on process variance
sigma.sq.a <- 2
sigma.sq.b <- 1
# Inverse gamma prior on random effects variance
tau.sq.a <- 2
tau.sq.b <- 1
alpha <- rep(alpha.start, n.alpha)
beta <- matrix(beta.start, nrow = n.ind, ncol = n.beta)
sigma.sq <- sigma.sq.start
tau.sq <- tau.sq.start
alpha.samples <- matrix(0, nrow = n.alpha, ncol = n.iter)
beta.samples <- matrix(0, nrow = n.ind, ncol = n.iter)
fitted.samples <- matrix(0, nrow = n, ncol = n.iter)
tau.sq.samples <- rep(0, n.iter)
sigma.sq.samples <- rep(0, n.iter)
post.dens.samples <- matrix(0, n, n.iter)
post.log.dens.samples <- matrix(0, n, n.iter)
XTX <- t(X)%*%X
# Update alpha samples
V <- chol2inv(chol(XTX / sigma.sq + diag(1/alpha.var, n.alpha)))
sum.diffs <- rep(0, n.alpha)
for (i in 1:n.ind) {
X.i <- X[ind == i, ]
y.i <- y[ind == i]
# W.i <- W[ind == i, ]
W.i <- as.matrix(W[ind == i, ])
# sum.diffs <- sum.diffs + t(X.i) %*% (y.i - ones.s*beta[i] - w.i * beta.1[i])
sum.diffs <- sum.diffs + t(X.i) %*% (y.i - W.i%*% beta[i, ])
}
v <- sum.diffs / sigma.sq
alpha <- rmvn(1, V%*%v, V)
alpha
rm(list = ls())
source("sim.R")
source("singleIndexModel.R")
library(coda)
# Main program for testing the univariate model with simulated data
# Author: Jeffrey W. Doser
# sim-main.R --------------------------------------------------------------
# Simulate data
dat <- sim.univariate.data()
# Run the model
out <- univar.sound.model(n.iter = 500, n.sites = dat$n.sites, data = dat$y,
ind = dat$ind, X = dat$X, alpha.start = 0,
beta.start = 0, sigma.sq.start = 1,
tau.sq.start = 1,index = 'sim')
alpha.samples <- out$alpha.samples
tau.sq.samples <- out$tau.sq.samples
sigma.sq.samples <- out$sigma.sq.samples
beta.samples <- out$beta.samples
n.iter <- out$n.iter
plot(mcmc(t(alpha.samples)),density = FALSE)
plot(mcmc(tau.sq.samples), density = FALSE)
plot(mcmc(sigma.sq.samples), density = FALSE)
theta <- cbind(t(alpha.samples), tau.sq.samples, sigma.sq.samples)
colnames(theta) <- c(paste0("alpha.", 1:n.alpha), "tau.sq.", "sigma.sq")
burn.in <- floor(0.5 * n.iter)
sub <- (burn.in+1):n.iter
summary(window(mcmc(theta), start = burn.in))
n.alpha <- nrow(alpha.samples)
colnames(theta) <- c(paste0("alpha.", 1:n.alpha), "tau.sq.", "sigma.sq")
burn.in <- floor(0.5 * n.iter)
sub <- (burn.in+1):n.iter
summary(window(mcmc(theta), start = burn.in))
dat$alpha
beta.hat.mean <- apply(beta.samples[, sub], 1, mean)
plot(beta.true[, 1], beta.hat.mean)
beta.hat.mean <- apply(beta.samples[, sub], 1, mean)
beta.true <- dat$beta
plot(beta.true[, 1], beta.hat.mean)
lines(beta.true[, 1], beta.true[, 1], col = 'red')
rm(list = ls())
library(coda)
source("singleIndexModel.R")
# Main program to call univariate acoustic index model and output the
# posterior samples for all parameters of interest.
# Author: Jeffrey W. Doser
# Main Program ------------------------------------------------------------
out <- univar.sound.model(n.iter = 500,
n.sites = 13,
data = read.csv("../../data/orderedIndices.csv")$ndsi,
ind = read.table("../../data/ind")[, 1],
X = as.matrix(read.table("../../data/X-year")),
alpha.start = 0,
beta.start = 0,
sigma.sq.start = 1,
tau.sq.start = 1,
index = 'NDSI')
alpha.samples <- out$alpha.samples
sigma.sq.samples <- out$sigma.sq.samples
tau.sq.samples <- out$tau.sq.samples
post.dens.samples <- out$post.dens.samples
post.log.dens.samples <- out$post.log.dens.samples
n.iter <- out$n.iter
# Compute WAIC for model comparison
ppd <- sum(log(apply(post.dens.samples, 1, sum) / n.iter))
p.d <- sum(apply(post.log.dens.samples, 1, var))
waic <- -2 * ppd + 2 * p.d
waic
theta <- cbind(t(alpha.samples), tau.sq.samples, sigma.sq.samples)
n.alpha <- nrow(alpha.samples)
colnames(theta) <- c(paste0("alpha.", 0:(n.alpha-1)), "tau.sq.", "sigma.sq")
